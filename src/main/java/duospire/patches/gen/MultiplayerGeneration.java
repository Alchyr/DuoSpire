package duospire.patches.gen;

import basemod.BaseMod;
import basemod.Pair;
import com.megacrit.cardcrawl.actions.AbstractGameAction;
import com.megacrit.cardcrawl.cards.AbstractCard;
import duospire.DuoSpire;
import duospire.util.BytecodeModifier;
import duospire.util.BytecodeTranslator;
import duospire.util.NotDeprecatedFilter;
import duospire.util.ReferenceReplacer;
import javassist.*;
import javassist.bytecode.*;
import javassist.expr.*;
import org.clapper.util.classutil.*;

import java.lang.reflect.Field;
import java.lang.reflect.Modifier;
import java.util.*;

/*
    Issue list:

    1. It doesn't change anything yet.

    2. specialinvoke calls in methods where the superclass is also a modified class are not fixed.
        - Edit constant pool? Is just changing what it references in the constant pool enough?
    3. This also applies to classes inside classes?

    4. Static fields. These are used quite a bit for mechanics.
        In the case where a field is of a replaced type, setting them could cause issues.
        Generate a class to hold modified versions of static fields to the new modified type?
        (This would be something needed for modded characters, likely.)
        However, only modifying static fields like this would result in the linked mechanics not working in all likelihood.
 */

/*
    The process of editing a method/constructor body:

    Iterate through bytecode, find the instruction where you want to modify.
    Usually a method invoke or field get/put.
    Javassist generates a MethodCall/FieldAccess based on the position information + code iterator + method info
    https://github.com/jboss-javassist/javassist/blob/52629ee8b867f5a2bb4ff24351b10f24efe1bcac/src/main/javassist/expr/MethodCall.java#L195
    Then this method is used to modify/compile new code.

    Method call example: Check if passed instruction is invoke. Get op total length.
    Create a Javac (compiler) instance jc and give it the necessary context for what is available in the current position.
    This includes determining the variable index to store the return value based on max locals.
    If the method needs a return but $_ is missing throw exception.
    Get bytecode of jc.
    Add instructions to store the parameters of the original method call in variables (storeStack) to bytecode.
    CodeAttribute.getMaxLocals is used to determine starting variable index to use.
    Stores all parameters as well as an instruction to store the instance, which will store a null if static.
    Record those new available variables into jc.
    Add to bytecode the return value variable (if not void). Put a null/0 on stack, store it in result variable.
    Compile the statement using jc (exception occurs here if code is no good)
    If it's non-void, add a load to bytecode that loads result value variable onto the stack.
    Perform the bytecode replacement.
    First, the original instructions (besides the first) are replaced with NOPs.
    If the generated bytecode requires more instructions than the original, generate a gap of the difference in size to use.
    Gap generation also returns the position of the beginning of the gap, as it is not guaranteed to be at the exact pos.
    Write the generated bytecode.
    *The methods in the Bytecode class that modify it also add to the constant pool appropriately.*
    The methods of ConstPool that add to it also return the index (of existing if already contained).
    Adjust the exception table.

    The expression's maximum locals and stack are tracked.
    After all modification is done, the CodeAttribute's max locals/max stack are updated.
 */

public class MultiplayerGeneration {
    private static final String PACKAGE_PREFIX = "duospire.";
    private static final String NAME_PREFIX = "DuoSpire";

    private static final Set<String> noReplace = new HashSet<>();
    static {
        noReplace.add(AbstractCard.class.getName());
        //noReplace.add(CustomCard.class.getName());
        noReplace.add(AbstractGameAction.class.getName());
        noReplace.add(Object.class.getName()); //hopefully nothing gets this far.
    }
    private static final Map<String, CtClass> classReplacements = new HashMap<>();
    private static final Map<CtClass, String> superclasses = new HashMap<>();
    private static final ClassMap classMap = new ClassMap();

    private static final Map<String, List<Pair<CtClass, List<CtClass>>>> dependent = new HashMap<>();

    private static final List<CtClass> generated = new ArrayList<>();
    private static final List<CtClass> generatedCards = new ArrayList<>(); //Cards *only* go in this list as they need specific modifications.

    private static Field isModified; //This is only part of CtClassType but the class is package-private making it inconvenient to reference directly.

    //private static CtClass ctAbstractCard = null;

    private static void registerReplacement(String original, CtClass replacement) {
        if (original.equals(replacement.getName())) {
            System.out.println("\t- UNCHANGED NAME?");
        }
        classReplacements.put(original, replacement);
        classMap.put(original, replacement.getName());
    }

    public static void patch(ClassFinder finder, ClassPool pool) throws NotFoundException, BadBytecode {
        System.out.println("Generating multiplayer card and relic variants.");

        classReplacements.clear();
        classMap.clear();

        ClassFilter cardFilter = new AndClassFilter(
                new NotClassFilter(new InterfaceOnlyClassFilter()),
                new NotDeprecatedFilter(),
                new SubclassClassFilter(AbstractCard.class)
        );
        ClassFilter actionFilter = new AndClassFilter(
                new NotClassFilter(new InterfaceOnlyClassFilter()),
                new NotDeprecatedFilter(),
                new SubclassClassFilter(AbstractGameAction.class)
        );

        //ctAbstractCard = pool.get(AbstractCard.class.getName());
        System.out.println("\t- Generating class copies.");

        ArrayList<ClassInfo> actionClasses = new ArrayList<>();
        finder.findClasses(actionClasses, actionFilter);

        generateClasses(pool, actionClasses, generated);

        ArrayList<ClassInfo> cardClasses = new ArrayList<>();
        finder.findClasses(cardClasses, cardFilter);

        generateClasses(pool, cardClasses, generatedCards);

        if (!dependent.isEmpty()) {
            System.out.println("\t- Superclasses for " + dependent.size() + " classes were not generated.");
        }

        replaceClasses(pool);

        multiplayerAdjustments(generated, generatedCards);

        registerCards(pool);

        BytecodeTranslator.translate(pool, "duospire.com.evacipated.cardcrawl.mod.bard.cards.DuoSpireLocateObject", "use");
    }

    private static boolean handled(CtClass clz) {
        return classReplacements.containsKey(clz.getName()) || noReplace.contains(clz.getName());
    }

    private static void generateClasses(ClassPool pool, List<ClassInfo> baseClasses, List<CtClass> generated) throws NotFoundException {
        for (ClassInfo classInfo : baseClasses)
        {
            CtClass clz = pool.get(classInfo.getClassName());

            generateClass(pool, clz, generated);
        }
    }

    private static void generateClass(ClassPool pool, CtClass clz, List<CtClass> generated) {
        try
        {
            Collection<?> references = clz.getRefClasses();
            for (Object o : references) {
                CtClass reference = pool.getOrNull(o.toString());
                if (reference == null) {
                    System.out.println("\t\t- Class " + clz.getSimpleName() + " refers to an unloaded class, " + o + ", and will be skipped.");
                    return;
                }
            }

            CtClass superclass = clz.getSuperclass();

            String origName = clz.getName();

            if (superclass != null) {
                if (!handled(superclass)) {
                    if (DuoSpire.FULL_DEBUG_LOGGING)
                        System.out.println("\t\t- Class " + clz.getSimpleName() + " waiting for " + superclass.getSimpleName() + ".");
                    dependent.compute(superclass.getName(), (k, v)->{
                        if (v == null)
                            v = new ArrayList<>();
                        v.add(new Pair<>(clz, generated));
                        return v;
                    });
                    return;
                }
                else if (classReplacements.containsKey(superclass.getName())) {
                    String newName = clz.getPackageName();
                    if (newName == null)
                        newName = PACKAGE_PREFIX;
                    else
                        newName = PACKAGE_PREFIX + newName + ".";
                    newName += NAME_PREFIX + clz.getSimpleName();

                    clz.setName(newName);
                    clz.setSuperclass(classReplacements.get(superclass.getName()));
                    superclasses.put(clz, superclass.getName());
                }
                else {
                    //Non-replaced superclass
                    String newName = clz.getPackageName();
                    if (newName == null)
                        newName = PACKAGE_PREFIX;
                    else
                        newName = PACKAGE_PREFIX + newName + ".";
                    newName += NAME_PREFIX + clz.getSimpleName();

                    clz.setName(newName);
                }
            }
            else {
                //No superclass...?
                String newName = clz.getPackageName();
                if (newName == null)
                    newName = PACKAGE_PREFIX;
                else
                    newName = PACKAGE_PREFIX + newName + ".";
                newName += NAME_PREFIX + clz.getSimpleName();

                clz.setName(newName);
            }

            try {
                if (isModified == null) {
                    isModified = clz.getClass().getDeclaredField("wasChanged");
                    isModified.setAccessible(true);
                }
                isModified.set(clz, true);

                generated.add(clz);

                if (DuoSpire.FULL_DEBUG_LOGGING)
                    System.out.println("\t\t- Copy generated: " + clz.getSimpleName());

                registerReplacement(origName, clz);
                //I also might be creating modified constructors, so I'll need to add the modified parameter info as well.

                List<Pair<CtClass, List<CtClass>>> dependencies = dependent.remove(origName);
                if (dependencies != null) {
                    for (Pair<CtClass, List<CtClass>> dependency : dependencies) {
                        generateClass(pool, dependency.getKey(), dependency.getValue());
                    }
                }
            }
            catch (NoSuchFieldException | IllegalAccessException e) {
                System.out.println("\t\t- Failed to mark new class as modified: " + clz.getSimpleName());
            } //This ensures it will be compiled by ModTheSpire.
        } catch (Exception e) {
            System.out.println("\t\t- Error occurred while generating copy of class: " + clz.getSimpleName() + "\n");
            e.printStackTrace();
        }
    }


    private static void adjustFieldsAndSignatures(List<CtClass> toAdjust) {
        CtField[] fields;
        CtConstructor[] constructors;
        CtMethod[] methods;

        for (CtClass clz : toAdjust) {
            try {
                //Fields
                {
                    fields = clz.getDeclaredFields();
                    for (CtField field : fields) {
                        String fieldType = field.getType().getName();
                        CtClass replacement = classReplacements.get(fieldType);
                        if (replacement != null) {
                            String name = field.getName();
                            int modifiers = field.getModifiers();
                            clz.removeField(field);
                            CtField alt = new CtField(replacement, name, clz);
                            alt.setModifiers(modifiers);
                            clz.addField(alt);
                            System.out.println("\t\t- Changed type of field " + name + " to " + replacement.getSimpleName());
                        }
                    }
                }
                //Constructors
                {
                    constructors = clz.getDeclaredConstructors();

                    for (CtConstructor con : constructors) {
                        if (con.isClassInitializer())
                            continue;

                        CtClass[] params = con.getParameterTypes();
                        if (params == null)
                            continue;

                        CtClass[] altParams = null;
                        for (int i = 0; i < params.length; ++i) {
                            CtClass replacement = classReplacements.get(params[i].getName());
                            if (replacement != null) {
                                if (altParams == null) {
                                    altParams = new CtClass[params.length];
                                    System.arraycopy(params, 0, altParams, 0, i);
                                }
                                altParams[i] = replacement;
                            }
                            else if (altParams != null) {
                                altParams[i] = params[i];
                            }
                        }

                        if (altParams != null) {
                            clz.removeConstructor(con);
                            CtConstructor replacement = new CtConstructor(con, clz, classMap);
                            /*CtConstructor replacement = new CtConstructor(altParams, clz);
                            replacement.setModifiers(con.getModifiers());
                            replacement.setExceptionTypes(con.getExceptionTypes());
                            replacement.setBody(con, classMap);*/
                            clz.addConstructor(replacement);
                        }
                    }
                }
                //Methods
                {
                    methods = clz.getDeclaredMethods();

                    for (CtMethod mth : methods) {
                        CtClass[] params = mth.getParameterTypes();
                        if (params == null)
                            continue;

                        CtClass[] altParams = null;
                        for (int i = 0; i < params.length; ++i) {
                            CtClass replacement = classReplacements.get(params[i].getName());
                            if (replacement != null) {
                                if (altParams == null) {
                                    altParams = new CtClass[params.length];
                                    System.arraycopy(params, 0, altParams, 0, i);
                                }
                                altParams[i] = replacement;
                            }
                            else if (altParams != null) {
                                altParams[i] = params[i];
                            }
                        }

                        if (altParams != null) {
                            clz.removeMethod(mth);
                            CtMethod replacement = new CtMethod(mth, clz, classMap);
                            clz.addMethod(replacement);
                        }
                    }
                }
            } catch (NotFoundException | CannotCompileException e) {
                System.out.println("\t\t- Error occurred while patching class: " + clz.getSimpleName() + "\n");
                e.printStackTrace();
            }
        }
    }

    private static void replaceClasses(ClassPool pool) throws NotFoundException, BadBytecode {
        //need to replace any references to the original actions in the actions themselves as well

        System.out.println("\t- Adjusting fields and method signatures.");
        adjustFieldsAndSignatures(generated);
        adjustFieldsAndSignatures(generatedCards);

        System.out.println("\t- Replacing references.");
        ReferenceReplacer replacer = new ReferenceReplacer(classReplacements);
        replacer.replaceAll(generated);
        replacer.replaceAll(generatedCards);
    }

    private static void multiplayerAdjustments(List<CtClass> general, List<CtClass> cards) {
        ClassReplacer generalAdjuster = new ClassReplacer(classReplacements);
        CardAdjuster cardAdjuster = new CardAdjuster(classReplacements);

        generalAdjuster.adjust(general);
        cardAdjuster.adjust(cards);
    }

    private static class ClassReplacer extends ExprEditor {
        final Map<String, CtClass> classReplacements;

        public ClassReplacer(Map<String, CtClass> classReplacements) {
            this.classReplacements = classReplacements;
        }

        public void adjust(List<CtClass> toAdjust) {
            CtConstructor[] constructors;
            CtMethod[] methods;

            for (CtClass clz : toAdjust) {
                try {
                    constructors = clz.getDeclaredConstructors();
                    modifyConstructors(clz, constructors);

                    methods = clz.getDeclaredMethods();
                    modifyMethods(clz, methods);
                } catch (CannotCompileException e) {
                    System.out.println("\t\t- Error occurred while patching class: " + clz.getSimpleName() + "\n");
                    e.printStackTrace();
                }
            }
        }

        public void modifyConstructors(CtClass clz, CtConstructor[] constructors) throws CannotCompileException {
            for (CtConstructor constructor : constructors) {
                preModify(clz, constructor);
                constructor.instrument(this);
                postModify(clz, constructor);
            }
        }

        public void modifyMethods(CtClass clz, CtMethod[] methods) throws CannotCompileException {
            for (CtMethod method : methods) {
                preModify(clz, method);
                method.instrument(this);
                postModify(clz, method);
            }
        }

        protected void preModify(CtClass clz, CtConstructor c) throws CannotCompileException {}
        protected void preModify(CtClass clz, CtMethod m) throws CannotCompileException {}

        protected void postModify(CtClass clz, CtConstructor c) throws CannotCompileException {}
        protected void postModify(CtClass clz, CtMethod m) throws CannotCompileException {}

        @Override
        public void edit(NewExpr e) throws CannotCompileException {
            CtClass replacement = classReplacements.get(e.getClassName());

            if (replacement != null) {
                System.out.println("UNREPLACED NEWEXPR");
                //e.replace("$_ = new " + replacement.getName() + "($$);");
            }
        }

        @Override
        public void edit(NewArray a) throws CannotCompileException {
            CtClass replacement;
            try {
                replacement = classReplacements.get(a.getComponentType().getName());
            } catch (NotFoundException e) {
                e.printStackTrace();
                return;
            }

            if (replacement != null) {
                System.out.println("UNREPLACED NEWARRAY");
                /*
                int dims = a.getCreatedDimensions();
                StringBuilder arrDef = new StringBuilder("$_ = new ").append(replacement.getName());
                for (int i = 0; i < dims; ++i) {
                    arrDef.append('[').append('$').append(i + 1).append(']');
                }
                arrDef.append(';');
                a.replace(arrDef.toString());*/
            }
        }

        @Override
        public void edit(FieldAccess f) {
            if (f.isStatic())
                return;

            CtClass replacement = classReplacements.get(f.getClassName());
            if (replacement != null) {
                System.out.println("UNREPLACED FIELDACCESS");
            }
        }

        @Override
        public void edit(Instanceof i) throws CannotCompileException {
            CtClass replacement;
            try {
                replacement = classReplacements.get(i.getType().getName());
            } catch (NotFoundException e) {
                e.printStackTrace();
                return;
            }

            if (replacement != null) {
                System.out.println("UNREPLACED INSTANCEOF");
                //i.replace("$_ = $1 instanceof " + replacement.getName() + ";");
            }
        }

        @Override
        public void edit(Cast c) throws CannotCompileException {
            CtClass replacement;
            try {
                replacement = classReplacements.get(c.getType().getName());
            } catch (NotFoundException e) {
                e.printStackTrace();
                return;
            }

            if (replacement != null) {
                System.out.println("UNREPLACED CAST");
                //c.replace("$_ = (" + replacement.getName() + ") $1;");
            }
        }
    }

    private static class CardAdjuster extends ClassReplacer {
        public CardAdjuster(Map<String, CtClass> classReplacements) {
            super(classReplacements);
        }

        boolean callsSuper = false;

        @Override
        protected void preModify(CtClass clz, CtConstructor c) {
            callsSuper = false;
        }

        @Override
        public void edit(ConstructorCall c) throws CannotCompileException {
            super.edit(c);
            callsSuper = c.isSuper();
        }

        @Override
        protected void postModify(CtClass clz, CtConstructor c) throws CannotCompileException {
            if (callsSuper) {
                c.insertAfter("{" +
                        "this.cardID = " + DuoSpire.class.getName() + ".oncePrefix(this.cardID);" +
                        "this.color = " + EnumPlace.class.getName() + ".getAltColor(this.color);" +
                        "}");
            }
        }
    }

    private static void registerCards(ClassPool pool) {
        try {
            CtClass duoSpireBase = pool.get(DuoSpire.class.getName());

            CtMethod registerCards = duoSpireBase.getDeclaredMethod("receiveEditCards");

            StringBuilder cardRegistration = new StringBuilder("{");

            String noParams = Descriptor.ofParameters(new CtClass[0]);

            for (CtClass cardClass : generatedCards) {
                try {
                    for (CtConstructor con : cardClass.getConstructors()) {
                        if (con.isConstructor() && con.getMethodInfo2().getDescriptor().startsWith(noParams)) {
                            //Found no-parameter constructor. Safe to register.
                            cardRegistration.append(BaseMod.class.getName()).append(".addCard(new ")
                                    .append(cardClass.getName()).append("());");
                        }
                    }
                }
                catch (Exception e) {
                    System.out.println("\t- Error occurred while generating card registration for " + cardClass.getSimpleName());
                    e.printStackTrace();
                }
            }
            cardRegistration.append('}');

            registerCards.setBody(cardRegistration.toString());
        } catch (NotFoundException | CannotCompileException e) {
            System.out.println("\t- Error occurred while attempted to generate card registration.");
            e.printStackTrace();
        }
    }

    private static class SuperFixer extends ExprEditor {
        final Map<String, CtClass> classReplacements;
        //CtClass currentClass = null;
        CtMember currentMember = null;
        Map<CtMember, BytecodeModifier.BytecodeChanges> bytecodeLater = new HashMap<>();

        public SuperFixer(Map<String, CtClass> classReplacements) {
            this.classReplacements = classReplacements;
        }

        public void fix(List<CtClass> toAdjust) {
            CtConstructor[] constructors;
            CtMethod[] methods;

            for (CtClass clz : toAdjust) {
                try {
                    constructors = clz.getDeclaredConstructors();
                    modifyConstructors(clz, constructors);

                    methods = clz.getDeclaredMethods();
                    modifyMethods(clz, methods);
                } catch (CannotCompileException | BadBytecode | NotFoundException e) {
                    System.out.println("\t\t- Error occurred while fixing super calls in class: " + clz.getSimpleName() + "\n");
                    e.printStackTrace();
                }
            }
        }

        public void modifyConstructors(CtClass clz, CtConstructor[] constructors) throws CannotCompileException, NotFoundException, BadBytecode {
            bytecodeLater.clear();
            for (CtConstructor constructor : constructors) {
                currentMember = constructor;
                constructor.instrument(this);
            }

            for (Map.Entry<CtMember, BytecodeModifier.BytecodeChanges> entry : bytecodeLater.entrySet()) {
                fixBody(clz, entry);
            }
        }

        public void modifyMethods(CtClass clz, CtMethod[] methods) throws CannotCompileException, BadBytecode, NotFoundException {
            bytecodeLater.clear();
            for (CtMethod method : methods) {
                currentMember = method;
                method.instrument(this);
            }

            for (Map.Entry<CtMember, BytecodeModifier.BytecodeChanges> entry : bytecodeLater.entrySet()) {
                fixBody(clz, entry);
            }
        }

        private void fixFieldLater(CtMember currentMember, String originalClass, String field, CtClass replacement) {
            BytecodeModifier.BytecodeChanges changes = bytecodeLater.computeIfAbsent(currentMember, k -> new BytecodeModifier.BytecodeChanges());
            changes.addFieldChange(originalClass, field, replacement);
        }
        private void fixMethodLater(CtMember currentMember, String originalClass, String method, CtClass replacement) {
            BytecodeModifier.BytecodeChanges changes = bytecodeLater.computeIfAbsent(currentMember, k -> new BytecodeModifier.BytecodeChanges());
            changes.addMethodChange(originalClass, method, replacement);
        }

        @Override
        public void edit(MethodCall m) {
            CtClass replacement = classReplacements.get(m.getClassName());
            if (replacement != null) {
                CtMethod method;
                try {
                    method = m.getMethod();
                } catch (NotFoundException e) {
                    e.printStackTrace();
                    return;
                }

                if (!Modifier.isStatic(method.getModifiers()) && m.isSuper()) {
                    fixMethodLater(currentMember, m.getClassName(), m.getMethodName(), replacement);
                }
            }
        }

        @Override
        public void edit(FieldAccess f) {
            if (f.isStatic())
                return;

            CtClass replacement = classReplacements.get(f.getClassName());
            if (replacement != null) {
                fixFieldLater(currentMember, f.getClassName(), f.getFieldName(), replacement);
            }
        }

        protected void fixBody(CtClass clz, Map.Entry<CtMember, BytecodeModifier.BytecodeChanges> entry) throws BadBytecode, NotFoundException {
            CtMember toFix = entry.getKey();
            BytecodeModifier.BytecodeChanges issues = entry.getValue();
            System.out.println(clz.getName() + '.' + toFix.getName());

            if (toFix instanceof CtMethod) {
                BytecodeModifier modifier = new BytecodeModifier((CtMethod) toFix);
                modifier.modify(issues);
                if (DuoSpire.FULL_DEBUG_LOGGING)
                    System.out.println(new BytecodeTranslator((CtMethod) toFix).translate());
            }
            else if (toFix instanceof CtConstructor) {
                BytecodeModifier modifier = new BytecodeModifier((CtConstructor) toFix);
                modifier.modify(issues);
                if (DuoSpire.FULL_DEBUG_LOGGING)
                    System.out.println(new BytecodeTranslator((CtConstructor) toFix).translate());
            }
        }
    }
}
