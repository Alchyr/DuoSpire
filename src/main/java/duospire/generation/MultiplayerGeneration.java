package duospire.generation;

import basemod.BaseMod;
import basemod.Pair;
import basemod.abstracts.CustomCard;
import com.megacrit.cardcrawl.actions.AbstractGameAction;
import com.megacrit.cardcrawl.actions.common.DamageAction;
import com.megacrit.cardcrawl.cards.AbstractCard;
import com.megacrit.cardcrawl.core.AbstractCreature;
import com.megacrit.cardcrawl.monsters.AbstractMonster;
import com.megacrit.cardcrawl.unlock.UnlockTracker;
import duospire.DuoSpire;
import duospire.patches.gen.EnumPlace;
import duospire.util.NotDeprecatedFilter;
import javassist.*;
import javassist.bytecode.*;
import javassist.expr.*;
import org.clapper.util.classutil.*;

import java.lang.reflect.Modifier;
import java.util.*;

/*
    Issue list:

    1. It doesn't change anything yet.

    2. Static fields. These are used quite a bit for mechanics.
        In the case where a field is of a replaced type, setting them could cause issues.
        Generate a class to hold modified versions of static fields to the new modified type?
        (This would be something needed for modded characters, likely.)
        However, only modifying static fields like this would result in the linked mechanics not working in all likelihood.

    3. SpireSuper calls of existing content.
        Assuming the CtClasses that this renames are already modified, that would mean those modifications to the originals are lost?

        - I was correct. Swapping to pool.getAndRename provides a copy without reverting the original.
        - However, this results in the copies having the same issue of SpireSuper not being properly implemented.
        - I'll just have to implement it myself.
        - Solved.
    4. Custom dynamic variables attempt to access specific variables of specific classes.
        - Cannot be easily changed, as it is dependent on the text key.
        - Modify dynamic variable classes that use `instanceof` checks to use an `or` and somehow also access the modified?
    5. SpireFields.
    6. Well, just focus on the basegame first. Modded compatibility can come later.
 */

/*
    The process of editing a method/constructor body:

    Iterate through bytecode, find the instruction where you want to modify.
    Usually a method invoke or field get/put.
    Javassist generates a MethodCall/FieldAccess based on the position information + code iterator + method info
    https://github.com/jboss-javassist/javassist/blob/52629ee8b867f5a2bb4ff24351b10f24efe1bcac/src/main/javassist/expr/MethodCall.java#L195
    Then this method is used to modify/compile new code.

    Method call example: Check if passed instruction is invoke. Get op total length.
    Create a Javac (compiler) instance jc and give it the necessary context for what is available in the current position.
    This includes determining the variable index to store the return value based on max locals.
    If the method needs a return but $_ is missing throw exception.
    Get bytecode of jc.
    Add instructions to store the parameters of the original method call in variables (storeStack) to bytecode.
    CodeAttribute.getMaxLocals is used to determine starting variable index to use.
    Stores all parameters as well as an instruction to store the instance, which will store a null if static.
    Record those new available variables into jc.
    Add to bytecode the return value variable (if not void). Put a null/0 on stack, store it in result variable.
    Compile the statement using jc (exception occurs here if code is no good)
    If it's non-void, add a load to bytecode that loads result value variable onto the stack.
    Perform the bytecode replacement.
    First, the original instructions are replaced with NOPs.
    If the generated bytecode requires more instructions than the original, generate a gap of the difference in size to use.
    Gap generation also returns the position of the beginning of the gap, as it is not guaranteed to be at the exact pos.
    Write the generated bytecode.
    *The methods in the Bytecode class that modify it also add to the constant pool appropriately.*
    The methods of ConstPool that add to it also return the index (of existing if already contained).
    Adjust the exception table.

    The expression's maximum locals and stack are tracked.
    After all modification is done, the CodeAttribute's max locals/max stack are updated.
 */
//Goal:
        /*
            For each basegame card, generate a version of it (prefixed with DuoSpire:) for multiplayer.
            Any references to `AbstractDungeon.player` will have to be replaced.
            Skills that grant block and target none or self should use a CustomTargeting to target a player.
            If a card cannot target a player, they should reference the `p` variable passed into the method which will be
            the player who used the card.


            Attacks should work as normal. Maybe change position?

            Step 1 is going through every card that has to be modified, then checking all the actions they reference they add.
            Then also all the actions *those* actions reference.

            AbstractDungeon.player will be the current "front" player? Or perhaps just player 1?
            There will be two player instances. They are labeled with `I` and `II`. These will also be placed above enemy intents to show who they will damage.

            Basegame character classes probably won't be too much of an issue, they don't have inherent functionality.
            Issues could occur if someone has a class with its abilities attached to the player class and not a spirepatch on AbstractPlayer or something.
            Generate an alternate constructor, alternate class extending base class which invokes alternate constructor overriding relevant methods?
         */

public class MultiplayerGeneration {
    private static final Set<String> noReplace = new HashSet<>();
    static {
        noReplace.add(AbstractCard.class.getName());
        noReplace.add(AbstractMonster.class.getName());
        noReplace.add(AbstractCreature.class.getName());
        noReplace.add(CustomCard.class.getName());
        noReplace.add(AbstractGameAction.class.getName());
        noReplace.add(Object.class.getName()); //hopefully nothing gets this far.
    }
    private static final Map<String, CtClass> classReplacements = new HashMap<>();
    private static final ClassMap classMap = new ClassMap();

    public static void registerReplacement(String original, CtClass replacement) {
        if (original.equals(replacement.getName())) {
            System.out.println("\t- UNCHANGED NAME?");
        }
        classReplacements.put(original, replacement);
        classMap.put(original, replacement.getName());
    }

    private static final List<CtClass> generated = new ArrayList<>();
    private static final List<CtClass> generatedCards = new ArrayList<>(); //Cards *only* go in this list as they need specific modifications.
    private static final List<CtClass> generatedMonsters = new ArrayList<>(); //Cards *only* go in this list as they need specific modifications.

    //private static CtClass ctAbstractCard = null;

    public static void patch(ClassFinder finder, ClassPool pool) throws NotFoundException, BadBytecode {
        System.out.println("Generating multiplayer content variants.");

        classReplacements.clear();
        classMap.clear();

        ClassFilter cardFilter = new AndClassFilter(
                new NotClassFilter(new InterfaceOnlyClassFilter()),
                new NotDeprecatedFilter(),
                new SubclassClassFilter(AbstractCard.class)
        );
        ClassFilter actionFilter = new AndClassFilter(
                new NotClassFilter(new InterfaceOnlyClassFilter()),
                new NotDeprecatedFilter(),
                new SubclassClassFilter(AbstractGameAction.class)
        );
        ClassFilter monsterFilter = new AndClassFilter(
                new NotClassFilter(new InterfaceOnlyClassFilter()),
                new NotDeprecatedFilter(),
                new SubclassClassFilter(AbstractMonster.class)
        );

        System.out.println("\t- Generating class copies.");

        ClassGenerator generator = new ClassGenerator(classReplacements, noReplace);

        ArrayList<ClassInfo> actionClasses = new ArrayList<>();
        finder.findClasses(actionClasses, actionFilter);

        generator.generateClasses(pool, actionClasses, generated);

        ArrayList<ClassInfo> monsterClasses = new ArrayList<>();
        finder.findClasses(monsterClasses, monsterFilter);

        generator.generateClasses(pool, monsterClasses, generatedMonsters);

        ArrayList<ClassInfo> cardClasses = new ArrayList<>();
        finder.findClasses(cardClasses, cardFilter);

        generator.generateClasses(pool, cardClasses, generatedCards);

        if (!generator.clean()) {
            System.out.println("\t- Superclasses for " + generator.incomplete() + " classes were not generated.");
        }

        //TODO: For action classes, check which ones reference AbstractDungeon.player and generate alternate versions of them
        //with an alternate constructor. This will need to be utilized as part of replaceClasses, also requires adding an invokestatic instruction to add parameter?

        replaceClasses(pool);

        multiplayerAdjustments(generated, generatedCards);

        registerCards(pool);

        BytecodeTranslator.translate(pool, "duospire.com.megacrit.cardcrawl.actions.common.DuoSpireDamageAction", "use");
    }

    private static void adjustFieldsAndSignatures(List<CtClass> toAdjust) {
        CtField[] fields;
        CtConstructor[] constructors;
        CtMethod[] methods;

        for (CtClass clz : toAdjust) {
            try {
                //Fields
                {
                    fields = clz.getDeclaredFields();
                    for (CtField field : fields) {
                        String fieldType = field.getType().getName();
                        CtClass replacement = classReplacements.get(fieldType);
                        if (replacement != null) {
                            String name = field.getName();
                            int modifiers = field.getModifiers();
                            clz.removeField(field);
                            CtField alt = new CtField(replacement, name, clz);
                            alt.setModifiers(modifiers);
                            clz.addField(alt);
                            System.out.println("\t\t- Changed type of field " + name + " to " + replacement.getSimpleName());
                        }
                    }
                }
                //Constructors
                {
                    constructors = clz.getDeclaredConstructors();

                    for (CtConstructor con : constructors) {
                        if (con.isClassInitializer())
                            continue;

                        CtClass[] params = con.getParameterTypes();
                        if (params == null)
                            continue;

                        CtClass[] altParams = null;
                        for (int i = 0; i < params.length; ++i) {
                            CtClass replacement = classReplacements.get(params[i].getName());
                            if (replacement != null) {
                                if (altParams == null) {
                                    altParams = new CtClass[params.length];
                                    System.arraycopy(params, 0, altParams, 0, i);
                                }
                                altParams[i] = replacement;
                            }
                            else if (altParams != null) {
                                altParams[i] = params[i];
                            }
                        }

                        if (altParams != null) {
                            clz.removeConstructor(con);
                            CtConstructor replacement = new CtConstructor(con, clz, classMap);
                            clz.addConstructor(replacement);
                        }
                    }
                }
                //Methods
                {
                    methods = clz.getDeclaredMethods();

                    for (CtMethod mth : methods) {
                        CtClass[] params = mth.getParameterTypes();
                        if (params == null)
                            continue;

                        CtClass[] altParams = null;
                        for (int i = 0; i < params.length; ++i) {
                            CtClass replacement = classReplacements.get(params[i].getName());
                            if (replacement != null) {
                                if (altParams == null) {
                                    altParams = new CtClass[params.length];
                                    System.arraycopy(params, 0, altParams, 0, i);
                                }
                                altParams[i] = replacement;
                            }
                            else if (altParams != null) {
                                altParams[i] = params[i];
                            }
                        }

                        if (altParams != null) {
                            clz.removeMethod(mth);
                            CtMethod replacement = new CtMethod(mth, clz, classMap);
                            clz.addMethod(replacement);
                        }
                    }
                }
            } catch (NotFoundException | CannotCompileException e) {
                System.out.println("\t\t- Error occurred while patching class: " + clz.getSimpleName() + "\n");
                e.printStackTrace();
            }
        }
    }

    private static void replaceClasses(ClassPool pool) throws NotFoundException, BadBytecode {
        //need to replace any references to the original actions in the actions themselves as well

        System.out.println("\t- Adjusting fields and method signatures.");
        adjustFieldsAndSignatures(generated);
        adjustFieldsAndSignatures(generatedCards);

        System.out.println("\t- Replacing references.");
        ReferenceReplacer replacer = new ReferenceReplacer(classReplacements);
        replacer.replaceAll(generated);
        replacer.replaceAll(generatedCards);
    }

    private static void multiplayerAdjustments(List<CtClass> general, List<CtClass> cards) {
        ClassReplacer generalAdjuster = new ClassReplacer(classReplacements);
        CardAdjuster cardAdjuster = new CardAdjuster(classReplacements);

        generalAdjuster.adjust(general);
        cardAdjuster.adjust(cards);
    }

    private static class ClassReplacer extends ExprEditor {
        final Map<String, CtClass> classReplacements;

        public ClassReplacer(Map<String, CtClass> classReplacements) {
            this.classReplacements = classReplacements;
        }

        public void adjust(List<CtClass> toAdjust) {
            CtConstructor[] constructors;
            CtMethod[] methods;

            for (CtClass clz : toAdjust) {
                try {
                    constructors = clz.getDeclaredConstructors();
                    modifyConstructors(clz, constructors);

                    methods = clz.getDeclaredMethods();
                    modifyMethods(clz, methods);
                } catch (CannotCompileException e) {
                    System.out.println("\t\t- Error occurred while patching class: " + clz.getSimpleName() + "\n");
                    e.printStackTrace();
                }
            }
        }

        public void modifyConstructors(CtClass clz, CtConstructor[] constructors) throws CannotCompileException {
            for (CtConstructor constructor : constructors) {
                preModify(clz, constructor);
                constructor.instrument(this);
                postModify(clz, constructor);
            }
        }

        public void modifyMethods(CtClass clz, CtMethod[] methods) throws CannotCompileException {
            for (CtMethod method : methods) {
                preModify(clz, method);
                method.instrument(this);
                postModify(clz, method);
            }
        }

        protected void preModify(CtClass clz, CtConstructor c) throws CannotCompileException {}
        protected void preModify(CtClass clz, CtMethod m) throws CannotCompileException {}

        protected void postModify(CtClass clz, CtConstructor c) throws CannotCompileException {}
        protected void postModify(CtClass clz, CtMethod m) throws CannotCompileException {}

        @Override
        public void edit(MethodCall m) throws CannotCompileException {
            if (isAddToBot(m)) {

            }
            else if (isAddToTop(m)) {

            }
        }

        @Override
        public void edit(NewExpr e) throws CannotCompileException {
            CtClass replacement = classReplacements.get(e.getClassName());

            if (replacement != null) {
                System.out.println("UNREPLACED NEWEXPR");
                //e.replace("$_ = new " + replacement.getName() + "($$);");
            }
        }

        @Override
        public void edit(NewArray a) throws CannotCompileException {
            CtClass replacement;
            try {
                replacement = classReplacements.get(a.getComponentType().getName());
            } catch (NotFoundException e) {
                e.printStackTrace();
                return;
            }

            if (replacement != null) {
                System.out.println("UNREPLACED NEWARRAY");
                /*
                int dims = a.getCreatedDimensions();
                StringBuilder arrDef = new StringBuilder("$_ = new ").append(replacement.getName());
                for (int i = 0; i < dims; ++i) {
                    arrDef.append('[').append('$').append(i + 1).append(']');
                }
                arrDef.append(';');
                a.replace(arrDef.toString());*/
            }
        }

        @Override
        public void edit(FieldAccess f) {
            if (f.isStatic())
                return;

            CtClass replacement = classReplacements.get(f.getClassName());
            if (replacement != null) {
                System.out.println("UNREPLACED FIELDACCESS");
            }
        }

        @Override
        public void edit(Instanceof i) throws CannotCompileException {
            CtClass replacement;
            try {
                replacement = classReplacements.get(i.getType().getName());
            } catch (NotFoundException e) {
                e.printStackTrace();
                return;
            }

            if (replacement != null) {
                System.out.println("UNREPLACED INSTANCEOF");
                //i.replace("$_ = $1 instanceof " + replacement.getName() + ";");
            }
        }

        @Override
        public void edit(Cast c) throws CannotCompileException {
            CtClass replacement;
            try {
                replacement = classReplacements.get(c.getType().getName());
            } catch (NotFoundException e) {
                e.printStackTrace();
                return;
            }

            if (replacement != null) {
                System.out.println("UNREPLACED CAST");
                //c.replace("$_ = (" + replacement.getName() + ") $1;");
            }
        }
    }

    private static class CardAdjuster extends ClassReplacer {
        public CardAdjuster(Map<String, CtClass> classReplacements) {
            super(classReplacements);
        }

        boolean callsSuper = false;

        @Override
        protected void preModify(CtClass clz, CtConstructor c) {
            callsSuper = false;
        }

        @Override
        public void edit(ConstructorCall c) throws CannotCompileException {
            super.edit(c);
            callsSuper = c.isSuper();
        }

        @Override
        protected void postModify(CtClass clz, CtConstructor c) throws CannotCompileException {
            if (callsSuper && !Modifier.isAbstract(clz.getModifiers())) {
                c.insertAfter("{" +
                        "this.cardID = " + DuoSpire.class.getName() + ".oncePrefix(this.cardID);" +
                        "this.color = " + EnumPlace.class.getName() + ".getAltColor(this.color);" +
                        "}");
            }
        }
    }

    private static Set<String> addToBotClasses = new HashSet<>();
    static {
        addToBotClasses.add(AbstractCard.class.getName());
    }
    private static boolean isAddToBot(MethodCall m) {
        switch (m.getMethodName()) {
            case "addToBot":
                if (addToBotClasses.contains(m.getClassName())) {
                    return true;
                }
                break;
            case "addToBottom":
                break;
            default:
        }
        return false;
    }
    private static boolean isAddToTop(MethodCall m) {
        return false;
    }

    private static void registerCards(ClassPool pool) {
        try {
            CtClass duoSpireBase = pool.get(DuoSpire.class.getName());

            CtMethod registerCards = duoSpireBase.getDeclaredMethod("receiveEditCards");

            StringBuilder cardRegistration = new StringBuilder("{"); //.append(AbstractCard.class.getName()).append(" c;\n");

            String noParams = Descriptor.ofParameters(new CtClass[0]);

            cardRegistration.append(List.class.getName()).append(" cards = new ").append(ArrayList.class.getName()).append("();");

            outer:
            for (CtClass cardClass : generatedCards) {
                if (Modifier.isAbstract(cardClass.getModifiers())) {
                    continue;
                }
                try {
                    for (CtConstructor con : cardClass.getConstructors()) {
                        if (con.isConstructor() && con.getMethodInfo2().getDescriptor().startsWith(noParams)) {
                            //Found no-parameter constructor. Safe to register.
                            cardRegistration.append("cards.add(new ").append(cardClass.getName()).append("());");
                            continue outer;
                        }
                    }
                    System.out.println("\t- Card class " + cardClass.getSimpleName() + " has no no-parameter constructor.");
                }
                catch (Exception e) {
                    System.out.println("\t- Error occurred while generating card registration for " + cardClass.getSimpleName());
                    e.printStackTrace();
                }
            }

            //Original method of "AbstractCard c;" + "c = new Card()" for each card resulting in using a new variable for every card.
            cardRegistration.append(Iterator.class.getName()).append(" i = cards.iterator();");
            cardRegistration.append("while (i.hasNext()) {");
            cardRegistration.append(AbstractCard.class.getName()).append(" c = (").append(AbstractCard.class.getName()).append(") i.next();");
            cardRegistration.append(BaseMod.class.getName()).append(".addCard(c);");
            cardRegistration.append(UnlockTracker.class.getName()).append(".seenPref.putInteger(c.cardID, 1);");
            cardRegistration.append("}");

            cardRegistration.append(UnlockTracker.class.getName()).append(".seenPref.flush();");
            cardRegistration.append('}');

            registerCards.setBody(cardRegistration.toString());
        } catch (NotFoundException | CannotCompileException e) {
            System.out.println("\t- Error occurred while attempted to generate card registration.");
            e.printStackTrace();
        }
    }
}
